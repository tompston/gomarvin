package validate


import (
	"github.com/go-playground/validator/v10"
	"fmt"

	{{ if ( eq .ProjectInfo.Framework "chi") }}
	"encoding/json"
	"net/http"
	{{ end }}
)


type ErrorResponse struct {
	FailedField string `json:"failed_field"`
	Message     string `json:"message"`
}

type ValidationErrors struct {
	Errors []*ErrorResponse
}

func (e *ValidationErrors) Error() string {
	var message string
	for _, err := range e.Errors {
		message += fmt.Sprintf("Field %s: %s\n", err.FailedField, err.Message)
	}
	return message
}

// Return an understandabe / UI friendly message that potentially
// can be displayed on the client side, when validation for 
// a field fails. Be free to add new tags!
func messageForTag(fe validator.FieldError) string {

	field := fe.Field()
	param := fe.Param()
	tag := fe.Tag()

	switch tag {
	case "required":
		return field + " is required"
	case "email":
		return field + " must be a valid email address"
	case "min":
		return field + " should be at least " + param + " characters long"
	case "max":
		return field + " should be less than " + param + " characters long"
	}
	return field + " failed validation for " + tag + ", " + param
}

// Pass in the sent struct and check if the
// fields pass validation
func ValidateStruct(i interface{}) error {
	err := validator.New().Struct(i)
	if err != nil {
		var errors []*ErrorResponse
		for _, err := range err.(validator.ValidationErrors) {
			errors = append(errors, &ErrorResponse{
				FailedField: err.Field(),
				Message:     messageForTag(err),
			})
		}
		return &ValidationErrors{errors}
	}
	return nil
}


{{ if ( eq .ProjectInfo.Framework "chi") }}
func ValidateJSON(r *http.Request, payload interface{}) error {
	return json.NewDecoder(r.Body).Decode(payload)
}

func ValidatePayload(r *http.Request, payload interface{}) error {
	if err := json.NewDecoder(r.Body).Decode(payload); err != nil {
		return err
	}
	if err := ValidateStruct(payload); err != nil {
		return err
	}
	return nil
}
{{ end }}
